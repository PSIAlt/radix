// THIS FILE WAS AUTOGENERATED.
// DO NOT EDIT!

package radix

import "sync"
import "sync/atomic"

// nodeSyncSlice represents synchronized sorted array of *Node.
// Note that in most cases you should store it somewhere by pointer.
// This is needed because of non-pointer data inside, that used to syncrhonize usage.
type nodeSyncSlice struct {
	mu      sync.RWMutex
	data    []*Node
	readers int64
}

func newNodeSyncSlice(n int) *nodeSyncSlice {
	return &nodeSyncSlice{
		data: make([]*Node, 0, n),
	}
}

// newNodeSyncSliceFromSlice creates nodeSyncSlice with underlying data.
// Note that data is not copied and used by reference.
func newNodeSyncSliceFromSlice(data []*Node) *nodeSyncSlice {
	_nodeSyncSliceSortSource(data, 0, len(data))
	return &nodeSyncSlice{
		data: data,
	}
}

// _nodeSyncSliceSortSource sorts data for further use inside nodeSyncSlice.
func _nodeSyncSliceSortSource(data []*Node, lo, hi int) {
	if hi-lo <= 12 {
		// Do insertion sort.
		for i := lo + 1; i < hi; i++ {
			for j := i; j > lo && !(data[j-1].key <= data[j].key); j-- {
				data[j], data[j-1] = data[j-1], data[j]
			}
		}
		return
	}
	// Do quick sort.
	var (
		p = lo
		x = data[lo]
	)
	for i := lo + 1; i < hi; i++ {
		if data[i].key <= x.key {
			p++
			data[p], data[i] = data[i], data[p]
		}
	}
	data[p], data[lo] = data[lo], data[p]

	if lo < p {
		_nodeSyncSliceSortSource(data, lo, p)
	}
	if p+1 < hi {
		_nodeSyncSliceSortSource(data, p+1, hi)
	}
}

func (a *nodeSyncSlice) Has(x uint) bool {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case data[m].key == x:
				ok = true
				r = m
			case data[m].key < x:
				l = m + 1
			case data[m].key > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	return ok
}

func (a *nodeSyncSlice) Get(x uint) (*Node, bool) {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case data[m].key == x:
				ok = true
				r = m
			case data[m].key < x:
				l = m + 1
			case data[m].key > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !ok {
		return nil, false
	}
	return data[i], true
}

func (a *nodeSyncSlice) GetAny(it func() (uint, bool)) (*Node, bool) {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	for {
		k, ok := it()
		if !ok {
			break
		}
		// Binary search algorithm.
		var has bool
		var i int
		{
			l := 0
			r := len(data)
			for !has && l < r {
				m := l + (r-l)/2
				switch {
				case data[m].key == k:
					has = true
					r = m
				case data[m].key < k:
					l = m + 1
				case data[m].key > k:
					r = m
				}
			}
			i = r
			_ = i // in case when i not being used
		}
		if has {
			return data[i], true
		}
	}
	return nil, false
}

func (a *nodeSyncSlice) Getsert(x *Node) *Node {
	a.mu.Lock()
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == x.key:
				has = true
				r = m
			case a.data[m].key < x.key:
				l = m + 1
			case a.data[m].key > x.key:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if has {
		a.mu.Unlock()
		return a.data[i]
	}
	r := atomic.LoadInt64(&a.readers)
	switch {
	case r == 0: // No readers, insert inplace.
		if n := len(a.data); n == cap(a.data) {
			// No space for insertion. Grow.
			with := make([]*Node, len(a.data)+1, n*3/2+1)
			copy(with[:i], a.data[:i])
			copy(with[i+1:], a.data[i:])
			with[i] = x
			a.data = with
		} else {
			a.data = a.data[:len(a.data)+1]
			copy(a.data[i+1:], a.data[i:])
			a.data[i] = x
		}
	case r > 0: // Readers exists, do copy.
		grow := len(a.data) + 1
		if n := len(a.data); n == cap(a.data) {
			// No space for insertion. Grow.
			grow = len(a.data)*3/2 + 1
		}
		with := make([]*Node, len(a.data)+1, grow)
		copy(with[:i], a.data[:i])
		copy(with[i+1:], a.data[i:])
		with[i] = x
		a.data = with
	}
	a.mu.Unlock()
	return x
}

func (a *nodeSyncSlice) GetsertFn(k uint, factory func() *Node) *Node {
	a.mu.Lock()
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == k:
				has = true
				r = m
			case a.data[m].key < k:
				l = m + 1
			case a.data[m].key > k:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if has {
		a.mu.Unlock()
		return a.data[i]
	}
	x := factory()
	r := atomic.LoadInt64(&a.readers)
	switch {
	case r == 0: // No readers, insert inplace.
		if n := len(a.data); n == cap(a.data) {
			// No space for insertion. Grow.
			with := make([]*Node, len(a.data)+1, n*3/2+1)
			copy(with[:i], a.data[:i])
			copy(with[i+1:], a.data[i:])
			with[i] = x
			a.data = with
		} else {
			a.data = a.data[:len(a.data)+1]
			copy(a.data[i+1:], a.data[i:])
			a.data[i] = x
		}
	case r > 0: // Readers exists, do copy.
		grow := len(a.data) + 1
		if n := len(a.data); n == cap(a.data) {
			// No space for insertion. Grow.
			grow = len(a.data)*3/2 + 1
		}
		with := make([]*Node, len(a.data)+1, grow)
		copy(with[:i], a.data[:i])
		copy(with[i+1:], a.data[i:])
		with[i] = x
		a.data = with
	}
	a.mu.Unlock()
	return x
}

func (a *nodeSyncSlice) GetsertAnyFn(it func() (uint, bool), factory func() *Node) *Node {
	a.mu.Lock()
	for {
		k, ok := it()
		if !ok {
			break
		}
		// Binary search algorithm.
		var has bool
		var i int
		{
			l := 0
			r := len(a.data)
			for !has && l < r {
				m := l + (r-l)/2
				switch {
				case a.data[m].key == k:
					has = true
					r = m
				case a.data[m].key < k:
					l = m + 1
				case a.data[m].key > k:
					r = m
				}
			}
			i = r
			_ = i // in case when i not being used
		}
		if has {
			a.mu.Unlock()
			return a.data[i]
		}
	}
	x := factory()
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == x.key:
				has = true
				r = m
			case a.data[m].key < x.key:
				l = m + 1
			case a.data[m].key > x.key:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if has {
		panic("inserting item that is already exists")
	}
	r := atomic.LoadInt64(&a.readers)
	switch {
	case r == 0: // No readers, insert inplace
		if n := len(a.data); n == cap(a.data) {
			// No space for insertion. Grow.
			with := make([]*Node, len(a.data)+1, n*3/2+1)
			copy(with[:i], a.data[:i])
			copy(with[i+1:], a.data[i:])
			with[i] = x
			a.data = with
		} else {
			a.data = a.data[:len(a.data)+1]
			copy(a.data[i+1:], a.data[i:])
			a.data[i] = x
		}
	case r > 0: // readers exists, do copy
		grow := len(a.data) + 1
		if n := len(a.data); n == cap(a.data) {
			// No space for insertion. Grow.
			grow = len(a.data)*3/2 + 1
		}
		with := make([]*Node, len(a.data)+1, grow)
		copy(with[:i], a.data[:i])
		copy(with[i+1:], a.data[i:])
		with[i] = x
		a.data = with
	}
	a.mu.Unlock()
	return x
}

// Upsert inserts item x into array or updates existing one.
// It returns previous item (if were present) and a boolean flag that reports
// about previous item replacement. This flag is useful for non-pointer item types
// such as numbers or struct values.
func (a *nodeSyncSlice) Upsert(x *Node) (prev *Node, ok bool) {
	a.mu.Lock()
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == x.key:
				has = true
				r = m
			case a.data[m].key < x.key:
				l = m + 1
			case a.data[m].key > x.key:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	r := atomic.LoadInt64(&a.readers)
	switch {
	case r > 0 && has: // Readers exists, do copy.
		with := make([]*Node, len(a.data))
		copy(with, a.data)
		a.data = with
		fallthrough
	case r == 0 && has: // No readers: update in place.
		a.data[i], prev = x, a.data[i]
		ok = true
	case r == 0 && !has: // No readers, insert inplace
		if n := len(a.data); n == cap(a.data) {
			// No space for insertion. Grow.
			with := make([]*Node, len(a.data)+1, n*3/2+1)
			copy(with[:i], a.data[:i])
			copy(with[i+1:], a.data[i:])
			with[i] = x
			a.data = with
		} else {
			a.data = a.data[:len(a.data)+1]
			copy(a.data[i+1:], a.data[i:])
			a.data[i] = x
		}
	case r > 0 && !has: // Readers exists, do copy.
		grow := len(a.data) + 1
		if n := len(a.data); n == cap(a.data) {
			// No space for insertion. Grow.
			grow = len(a.data)*3/2 + 1
		}
		with := make([]*Node, len(a.data)+1, grow)
		copy(with[:i], a.data[:i])
		copy(with[i+1:], a.data[i:])
		with[i] = x
		a.data = with
	}
	a.mu.Unlock()
	return
}

func (a *nodeSyncSlice) Do(cb func([]*Node)) {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	cb(data)
}

func (a *nodeSyncSlice) AppendTo(p []*Node) []*Node {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	return append(p, data...)
}

func (a *nodeSyncSlice) Delete(x uint) (*Node, bool) {
	return a.DeleteCond(x, nil)
}

func (a *nodeSyncSlice) DeleteCond(x uint, predicate func(*Node) bool) (*Node, bool) {
	a.mu.Lock()
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == x:
				has = true
				r = m
			case a.data[m].key < x:
				l = m + 1
			case a.data[m].key > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !has {
		a.mu.Unlock()
		return nil, false
	}
	if predicate != nil && !predicate(a.data[i]) {
		a.mu.Unlock()
		return nil, false
	}
	prev := a.data[i]
	r := atomic.LoadInt64(&a.readers)
	switch {
	case r == 0: // No readers, delete inplace.
		a.data[i] = nil
		a.data = a.data[:i+copy(a.data[i:], a.data[i+1:])]
	case r > 0: // Has readers, copy.
		without := make([]*Node, len(a.data)-1)
		copy(without[:i], a.data[:i])
		copy(without[i:], a.data[i+1:])
		a.data = without
	}
	a.mu.Unlock()
	return prev, true
}

func (a *nodeSyncSlice) Ascend(cb func(x *Node) bool) bool {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	for _, x := range data {
		if !cb(x) {
			return false
		}
	}
	return true
}

func (a *nodeSyncSlice) AscendRange(x, y uint, cb func(x *Node) bool) bool {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	// Binary search algorithm.
	var hasX bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !hasX && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == x:
				hasX = true
				r = m
			case a.data[m].key < x:
				l = m + 1
			case a.data[m].key > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	// Binary search algorithm.
	var hasY bool
	var j int
	{
		l := i
		r := len(a.data)
		for !hasY && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == y:
				hasY = true
				r = m
			case a.data[m].key < y:
				l = m + 1
			case a.data[m].key > y:
				r = m
			}
		}
		j = r
		_ = j // in case when j not being used
	}
	for ; i < len(data) && i <= j; i++ {
		if !cb(data[i]) {
			return false
		}
	}
	return true
}

func (a *nodeSyncSlice) Len() int {
	a.mu.RLock()
	n := len(a.data)
	a.mu.RUnlock()
	return n
}
