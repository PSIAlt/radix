// THIS FILE WAS AUTOGENERATED.
// DO NOT EDIT!

package radix

type uintSortedArray struct {
	data []uint
}

func (a uintSortedArray) Has(x uint) bool {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == x:
				ok = true
				r = m
			case a.data[m] < x:
				l = m + 1
			case a.data[m] > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	return ok
}

func (a uintSortedArray) Get(x uint) (uint, bool) {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == x:
				ok = true
				r = m
			case a.data[m] < x:
				l = m + 1
			case a.data[m] > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !ok {
		return 0, false
	}
	return a.data[i], true
}

func (a uintSortedArray) Upsert(x uint) (cp uintSortedArray, prev uint) {
	var with []uint
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == x:
				has = true
				r = m
			case a.data[m] < x:
				l = m + 1
			case a.data[m] > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if has {
		with = make([]uint, len(a.data))
		copy(with, a.data)
		with[i], prev = x, a.data[i]
	} else {
		with = make([]uint, len(a.data)+1)
		copy(with[:i], a.data[:i])
		copy(with[i+1:], a.data[i:])
		with[i] = x
	}
	return uintSortedArray{with}, prev
}

func (a uintSortedArray) Delete(x uint) (uintSortedArray, uint, bool) {
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == x:
				has = true
				r = m
			case a.data[m] < x:
				l = m + 1
			case a.data[m] > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !has {
		return a, 0, false
	}
	without := make([]uint, len(a.data)-1)
	copy(without[:i], a.data[:i])
	copy(without[i:], a.data[i+1:])
	return uintSortedArray{without}, a.data[i], true
}

func (a uintSortedArray) Ascend(cb func(x uint) bool) bool {
	for _, x := range a.data {
		if !cb(x) {
			return false
		}
	}
	return true
}

func (a uintSortedArray) AscendRange(x, y uint, cb func(x uint) bool) bool {
	// Binary search algorithm.
	var hasX bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !hasX && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == x:
				hasX = true
				r = m
			case a.data[m] < x:
				l = m + 1
			case a.data[m] > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	// Binary search algorithm.
	var hasY bool
	var j int
	{
		l := i
		r := len(a.data)
		for !hasY && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == y:
				hasY = true
				r = m
			case a.data[m] < y:
				l = m + 1
			case a.data[m] > y:
				r = m
			}
		}
		j = r
		_ = j // in case when j not being used
	}
	for ; i < len(a.data) && i <= j; i++ {
		if !cb(a.data[i]) {
			return false
		}
	}
	return true
}

func (a uintSortedArray) Reset() uintSortedArray {
	return uintSortedArray{nil}
}

func (a uintSortedArray) Copy() []uint {
	ret := make([]uint, len(a.data))
	copy(ret, a.data)
	return ret
}

func (a uintSortedArray) Len() int {
	return len(a.data)
}
