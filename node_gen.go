// THIS FILE WAS AUTOGENERATED.
// DO NOT EDIT!

package radix

import "sync"
import "sync/atomic"

// nodeArray represents synchronized sorted array of *Node.
// Note that in most cases you should store it somewhere by pointer.
// This is needed because of non-pointer data inside, that used to syncrhonize usage.
type nodeArray struct {
	mu      sync.RWMutex
	data    []*Node
	readers int64
}

func newNodeArray() *nodeArray {
	return &nodeArray{}
}

func (a *nodeArray) Has(x uint) bool {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case data[m].key == x:
				ok = true
				r = m
			case data[m].key < x:
				l = m + 1
			case data[m].key > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	return ok
}

func (a *nodeArray) Get(x uint) (*Node, bool) {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case data[m].key == x:
				ok = true
				r = m
			case data[m].key < x:
				l = m + 1
			case data[m].key > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !ok {
		return nil, false
	}
	return data[i], true
}

func (a *nodeArray) Getsert(x *Node) *Node {
	a.mu.Lock()
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == x.key:
				has = true
				r = m
			case a.data[m].key < x.key:
				l = m + 1
			case a.data[m].key > x.key:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if has {
		a.mu.Unlock()
		return a.data[i]
	}
	r := atomic.LoadInt64(&a.readers)
	switch {
	case r == 0: // no readers, insert inplace
		if cap(a.data) == len(a.data) { // not enough storage in array
			goto copyCase
		}
		a.data = a.data[:len(a.data)+1]
		copy(a.data[i+1:], a.data[i:])
		a.data[i] = x
	copyCase:
		fallthrough
	case r > 0: // readers exists, do copy
		with := make([]*Node, len(a.data)+1)
		copy(with[:i], a.data[:i])
		copy(with[i+1:], a.data[i:])
		with[i] = x
		a.data = with
	}
	a.mu.Unlock()
	return x
}

func (a *nodeArray) GetsertFn(k uint, factory func() *Node) *Node {
	a.mu.Lock()
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == k:
				has = true
				r = m
			case a.data[m].key < k:
				l = m + 1
			case a.data[m].key > k:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if has {
		a.mu.Unlock()
		return a.data[i]
	}
	x := factory()
	r := atomic.LoadInt64(&a.readers)
	switch {
	case r == 0: // no readers, insert inplace
		if cap(a.data) == len(a.data) { // not enough storage in array
			goto copyCase
		}
		a.data = a.data[:len(a.data)+1]
		copy(a.data[i+1:], a.data[i:])
		a.data[i] = x
	copyCase:
		fallthrough
	case r > 0: // readers exists, do copy
		with := make([]*Node, len(a.data)+1)
		copy(with[:i], a.data[:i])
		copy(with[i+1:], a.data[i:])
		with[i] = x
		a.data = with
	}
	a.mu.Unlock()
	return x
}
func (a *nodeArray) Upsert(x *Node) (prev *Node) {
	a.mu.Lock()
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == x.key:
				has = true
				r = m
			case a.data[m].key < x.key:
				l = m + 1
			case a.data[m].key > x.key:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	r := atomic.LoadInt64(&a.readers)
	switch {
	case r > 0 && has: // readers exists, do copy
		with := make([]*Node, len(a.data))
		copy(with, a.data)
		a.data = with
		fallthrough
	case r == 0 && has: // no readers: update in place
		a.data[i], prev = x, a.data[i]
	case r == 0 && !has: // no readers, insert inplace
		if cap(a.data) == len(a.data) { // not enough storage in array
			goto copyCase
		}
		a.data = a.data[:len(a.data)+1]
		copy(a.data[i+1:], a.data[i:])
		a.data[i] = x
	copyCase:
		fallthrough
	case r > 0 && !has: // readers exists, do copy
		with := make([]*Node, len(a.data)+1)
		copy(with[:i], a.data[:i])
		copy(with[i+1:], a.data[i:])
		with[i] = x
		a.data = with
	}
	a.mu.Unlock()
	return
}

func (a *nodeArray) Do(cb func([]*Node)) {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	cb(data)
}

func (a *nodeArray) Delete(x uint) (*Node, bool) {
	a.mu.Lock()
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == x:
				has = true
				r = m
			case a.data[m].key < x:
				l = m + 1
			case a.data[m].key > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !has {
		a.mu.Unlock()
		return nil, false
	}
	prev := a.data[i]
	r := atomic.LoadInt64(&a.readers)
	switch {
	case r == 0: // no readers, delete inplace
		a.data[i] = nil
		a.data = a.data[:i+copy(a.data[i:], a.data[i+1:])]
	case r > 0: // has readers, copy
		without := make([]*Node, len(a.data)-1)
		copy(without[:i], a.data[:i])
		copy(without[i:], a.data[i+1:])
		a.data = without
	}
	a.mu.Unlock()
	return prev, true
}

func (a *nodeArray) Ascend(cb func(x *Node) bool) bool {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	for _, x := range data {
		if !cb(x) {
			return false
		}
	}
	return true
}

func (a *nodeArray) AscendRange(x, y uint, cb func(x *Node) bool) bool {
	a.mu.RLock()
	data := a.data
	atomic.AddInt64(&a.readers, 1)
	defer atomic.AddInt64(&a.readers, -1)
	a.mu.RUnlock()
	// Binary search algorithm.
	var hasX bool
	var i int
	{
		l := 0
		r := len(a.data)
		for !hasX && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == x:
				hasX = true
				r = m
			case a.data[m].key < x:
				l = m + 1
			case a.data[m].key > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	// Binary search algorithm.
	var hasY bool
	var j int
	{
		l := i
		r := len(a.data)
		for !hasY && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m].key == y:
				hasY = true
				r = m
			case a.data[m].key < y:
				l = m + 1
			case a.data[m].key > y:
				r = m
			}
		}
		j = r
		_ = j // in case when j not being used
	}
	for ; i < len(data) && i <= j; i++ {
		if !cb(data[i]) {
			return false
		}
	}
	return true
}

func (a *nodeArray) Len() int {
	a.mu.RLock()
	n := len(a.data)
	a.mu.RUnlock()
	return n
}
