package radix

// THIS FILE WAS AUTOGENERATED.
// DO NOT EDIT.

func pairQuickSort(data []Pair, lo, hi int) {
	if lo >= hi {
		return
	}
	// Quick sort partition algorithm.
	var p int
	{
		// Let x be a pivot
		x := data[lo]
		p = lo
		for i := lo + 1; i < hi; i++ {
			if data[i].Key <= x.Key {
				p++
				data[p], data[i] = data[i], data[p]
			}
		}
		data[p], data[lo] = data[lo], data[p]
	}
	pairQuickSort(data, lo, p)
	pairQuickSort(data, p+1, hi)
}

func pairInsertionSort(data []Pair, l, r int) {
	// Insertion sort algorithm.
	for i := l + 1; i < r; i++ {
		for j := i; j > l && data[j-1].Key > data[j].Key; j-- {
			data[j], data[j-1] = data[j-1], data[j]
		}
	}
}

func pairSort(data []Pair, l, r int) {
	if r-l > 12 {
		pairQuickSort(data, l, r)
		return
	}
	// Insertion sort algorithm.
	for i := l + 1; i < r; i++ {
		for j := i; j > l && data[j-1].Key > data[j].Key; j-- {
			data[j], data[j-1] = data[j-1], data[j]
		}
	}
}

func pairSearch(data []Pair, key uint) (int, bool) {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case data[m].Key == key:
				ok = true
				r = m
			case data[m].Key < key:
				l = m + 1
			case data[m].Key > key:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	return i, ok
}

func (p Path) has(k uint) (int, bool) {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(p.pairs)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case p.pairs[m].Key == k:
				ok = true
				r = m
			case p.pairs[m].Key < k:
				l = m + 1
			case p.pairs[m].Key > k:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	ok = ok && p.includes(i)
	return i, ok
}
