// THIS FILE WAS AUTOGENERATED.
// DO NOT EDIT!

package radix

func SortPair(data []Pair, lo, hi int) {
	if hi-lo <= 12 {
		// Do insertion sort.
		for i := lo + 1; i < hi; i++ {
			for j := i; j > lo && !(data[j-1].Key <= data[j].Key); j-- {
				data[j], data[j-1] = data[j-1], data[j]
			}
		}
		return
	}
	// Do quick sort.
	var (
		p = lo
		x = data[lo]
	)
	for i := lo + 1; i < hi; i++ {
		if data[i].Key <= x.Key {
			p++
			data[p], data[i] = data[i], data[p]
		}
	}
	data[p], data[lo] = data[lo], data[p]

	if lo < p {
		SortPair(data, lo, p)
	}
	if p+1 < hi {
		SortPair(data, p+1, hi)
	}
}

func SearchPair(data []Pair, key uint) (int, bool) {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(data)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case data[m].Key == key:
				ok = true
				r = m
			case data[m].Key < key:
				l = m + 1
			case data[m].Key > key:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	return i, ok
}

func (p Path) has(k uint) (int, bool) {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := len(p.pairs)
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case p.pairs[m].Key == k:
				ok = true
				r = m
			case p.pairs[m].Key < k:
				l = m + 1
			case p.pairs[m].Key > k:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	ok = ok && p.includes(i)
	return i, ok
}
