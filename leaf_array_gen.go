// THIS FILE WAS AUTOGENERATED.
// DO NOT EDIT!

package radix

const UintArrayCapacity = 15

type uintArray struct {
	data [UintArrayCapacity]uint
	size int
}

// newUintArray creates uintArray with underlying sorted copy of given data.
func newUintArray(data []uint) uintArray {
	a := uintArray{}
	a.size = copy(a.data[:], data)
	a.sort(0, a.size)
	return a
}

// sort sorts data for further use. It is intended to be
// used only once in newUintArray.
func (a *uintArray) sort(lo, hi int) {
	if hi-lo <= 12 {
		// Do insertion sort.
		for i := lo + 1; i < hi; i++ {
			for j := i; j > lo && !(a.data[j-1] <= a.data[j]); j-- {
				a.data[j], a.data[j-1] = a.data[j-1], a.data[j]
			}
		}
		return
	}
	// Do quick sort.
	var (
		p = lo
		x = a.data[lo]
	)
	for i := lo + 1; i < hi; i++ {
		if a.data[i] <= x {
			p++
			a.data[p], a.data[i] = a.data[i], a.data[p]
		}
	}
	a.data[p], a.data[lo] = a.data[lo], a.data[p]

	if lo < p {
		a.sort(lo, p)
	}
	if p+1 < hi {
		a.sort(p+1, hi)
	}
}

func (a *uintArray) Has(x uint) bool {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := a.size
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == x:
				ok = true
				r = m
			case a.data[m] < x:
				l = m + 1
			case a.data[m] > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	return ok
}

func (a *uintArray) Get(x uint) (uint, bool) {
	// Binary search algorithm.
	var ok bool
	var i int
	{
		l := 0
		r := a.size
		for !ok && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == x:
				ok = true
				r = m
			case a.data[m] < x:
				l = m + 1
			case a.data[m] > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !ok {
		return 0, false
	}
	return a.data[i], true
}

// Upsert inserts item x into array or updates existing one.
// It returns copy of uintArray, previous item (if were present) and a boolean
// flag that reports about previous item replacement. This flag is useful for
// non-pointer item types such as numbers or struct values.
//
// Note that it will panic on out of range insertion.
func (a uintArray) Upsert(x uint) (cp uintArray, prev uint, ok bool) {
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := a.size
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == x:
				has = true
				r = m
			case a.data[m] < x:
				l = m + 1
			case a.data[m] > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if has {
		a.data[i], prev = x, a.data[i]
		ok = true
	} else {
		a.size++
		copy(a.data[i+1:a.size], a.data[i:a.size-1])
		a.data[i] = x
		prev = 0
	}
	return a, prev, ok
}

func (a uintArray) Delete(x uint) (cp uintArray, prev uint, ok bool) {
	// Binary search algorithm.
	var has bool
	var i int
	{
		l := 0
		r := a.size
		for !has && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == x:
				has = true
				r = m
			case a.data[m] < x:
				l = m + 1
			case a.data[m] > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	if !has {
		return a, 0, false
	}
	a.size--
	prev = a.data[i]
	copy(a.data[i:a.size], a.data[i+1:a.size+1])
	return a, prev, true
}

func (a *uintArray) Ascend(cb func(x uint) bool) bool {
	for i := 0; i < a.size; i++ {
		if !cb(a.data[i]) {
			return false
		}
	}
	return true
}

func (a *uintArray) AscendRange(x, y uint, cb func(x uint) bool) bool {
	// Binary search algorithm.
	var hasX bool
	var i int
	{
		l := 0
		r := a.size
		for !hasX && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == x:
				hasX = true
				r = m
			case a.data[m] < x:
				l = m + 1
			case a.data[m] > x:
				r = m
			}
		}
		i = r
		_ = i // in case when i not being used
	}
	// Binary search algorithm.
	var hasY bool
	var j int
	{
		l := i
		r := a.size
		for !hasY && l < r {
			m := l + (r-l)/2
			switch {
			case a.data[m] == y:
				hasY = true
				r = m
			case a.data[m] < y:
				l = m + 1
			case a.data[m] > y:
				r = m
			}
		}
		j = r
		_ = j // in case when j not being used
	}
	for ; i < a.size && i <= j; i++ {
		if !cb(a.data[i]) {
			return false
		}
	}
	return true
}

func (a uintArray) Reset() uintArray {
	for i := 0; i < a.size; i++ {
		// Need to prevent memory leaks on complex structs.
		a.data[i] = 0
	}
	a.size = 0
	return a
}

func (a *uintArray) AppendTo(p []uint) []uint {
	return append(p, a.data[:a.size]...)
}

func (a *uintArray) Len() int {
	return a.size
}

func (a *uintArray) Cap() int {
	return UintArrayCapacity
}
